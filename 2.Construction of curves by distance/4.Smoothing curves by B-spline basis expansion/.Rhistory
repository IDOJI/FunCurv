path_train = "E:/FunCur/1.Data Indexing/2.Split train and test data/train_seed_4649.rds"
train_folded = readRDS(path_train)
path_train = "E:/FunCurv/1.Data Indexing/2.Split train and test data/train_seed_4649.rds"
path_test = "E:/FunCurv/1.Data Indexing/2.Split train and test data/test_seed_4649.rds"
test = readRDS(path_test_dataset)
path_test = "E:/FunCurv/1.Data Indexing/2.Split train and test data/test_seed_4649.rds"
test = readRDS(path_test)
## ğŸŸ¨ ê° atlasì— ëŒ€í•œ ì˜µì…˜ ì •ì˜ ==============================================================================
options_for_each_atlas_list <- list(
AAL3 = list(n_order = 4,
n_breaks = 300,
lambdas = exp(seq(-5, -4, 0.5))),
"1000Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-3, -2, 0.5))),
"900Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-2, -1, 0.5))),
"800Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-3, -2, 0.5))),
"700Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-2, -1, 0.5))),
"600Parcels" = list(n_order = 4,
n_breaks = 200,
lambdas = exp(seq(-2, -1, 0.5))),
"500Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-3, -2, 0.5))),
"400Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-3, -2, 0.5))),
"300Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-3, -2, 0.5))),
"200Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-2, -1, 0.5))),
"100Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-4, -3, 0.5)))
)
## ğŸŸ¨ FunImgARCWSF ====================================================================================================================
path_FC = "/Volumes/ADNI_SB_SSD_NTFS_4TB_Sandisk/FunCurv/2.Construction of curves by distance/3.Curves by Distance/FunImgARCWSF/Fisher Z FC"
path_FC = path_FC %>% adjust_path
# ğŸŸ¥ Load Functions & Packages ##########################################################################
# rm(list = ls())
Sys.setlocale("LC_ALL", "en_US.UTF-8")
## ğŸŸ¨Install and loading Packages ================================
install_packages = function(packages, load=TRUE) {
# load : load the packages after installation?
for(pkg in packages) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg)
}
if(load){
library(pkg, character.only = TRUE, quietly = T)
}
}
}
List.list = list()
List.list[[1]] = visual = c("ggpubr", "ggplot2", "ggstatsplot", "ggsignif", "rlang", "RColorBrewer", "reshape2")
List.list[[2]] = stat = c("fda", "MASS", "caret")
List.list[[3]] = data_handling = c("tidyverse", "dplyr", "clipr", "tidyr", "readr", "caret", "readxl")
List.list[[4]] = qmd = c("janitor", "knitr")
List.list[[5]] = texts = c("stringr", "stringi")
List.list[[6]] = misc = c("devtools")
List.list[[7]] = db = c("RMySQL", "DBI", "odbc", "RSQL", "RSQLite")
List.list[[8]] = sampling = c("rsample")
List.list[[9]] = excel = c("openxlsx")
List.list[[10]] = others = c("beepr")
packages_to_install_and_load = unlist(List.list)
install_packages(packages_to_install_and_load)
## ğŸŸ§dplyr =======================================================
filter = dplyr::filter
select = dplyr::select
# ê²½ë¡œ ìë™ ë³€í™˜ í•¨ìˆ˜ ì •ì˜
adjust_path <- function(path) {
# ìš´ì˜ì²´ì œì— ë”°ë¼ ê¸°ë³¸ ê²½ë¡œ ì•ë¶€ë¶„ ì„¤ì •
if (.Platform$OS.type == "windows") {
# macOS ê²½ë¡œë¥¼ Windows ê²½ë¡œë¡œ ë³€í™˜
path <- sub("^/Volumes/ADNI_SB_SSD_NTFS_4TB_Sandisk/", "E:/", path)
} else if (.Platform$OS.type == "unix" && grepl("darwin", R.version$os)) {
# ì´ë¯¸ macOS ê²½ë¡œì´ë¯€ë¡œ ê·¸ëŒ€ë¡œ ìœ ì§€
path <- path
} else {
stop("ì§€ì›ë˜ì§€ ì•ŠëŠ” ìš´ì˜ì²´ì œì…ë‹ˆë‹¤.")
}
# ìµœì¢… ê²½ë¡œ ë°˜í™˜
return(path)
}
# ğŸŸ¥ Define smoothing functions =========================================================================================================
## ğŸŸ¨ RID ë³€ê²½ =======================================================================
change_rid = function(rid){
sprintf("RID_%04d", rid)
}
## ğŸŸ¨ ê° atlasì— ì„œë¡œ ë‹¤ë¥¸ ì˜µì…˜ ì ìš©í•˜ëŠ” í•¨ìˆ˜ =======================================================================
apply_smoothing_to_atlas_files <- function(base_path,
train_folded,
test,
options_for_each_atlas_list,
common_options = list()) {
# ê²½ë¡œì—ì„œ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
file_list <- list.files(base_path, full.names = TRUE)
# íŒŒì¼ë³„ ì˜µì…˜ ì„ íƒ í•¨ìˆ˜ ì •ì˜
get_options_for_file <- function(file_name) {
if (grepl("AAL3", file_name)) {
return(options_for_each_atlas_list[["AAL3"]])
}
parcels_pattern <- stringr::str_extract(file_name, "\\d+Parcels")
if (!is.na(parcels_pattern) && parcels_pattern %in% names(options_for_each_atlas_list)) {
return(options_for_each_atlas_list[[parcels_pattern]])
}
return(list())
}
# ê° atlas íŒŒì¼ì— ëŒ€í•´ ì²˜ë¦¬
for (path_atlas in file_list) {
file_name <- tools::file_path_sans_ext(basename(path_atlas))
specific_options <- get_options_for_file(file_name)
# ì¤‘ë³µëœ path_export ì œê±°
final_options <- modifyList(common_options, specific_options)
final_options$path_export <- NULL  # path_export ì œê±°
# ğŸŸ¢ Atlasë³„ í´ë” ìƒì„±
atlas_export_path <- file.path(common_options$path_export, file_name)
if (!dir.exists(atlas_export_path)) {
dir.create(atlas_export_path, recursive = TRUE)
cat(crayon::green("Created export directory for atlas:"), crayon::bold(atlas_export_path), "\n")
}
# ğŸŸ¢ Test ë°ì´í„° ì²˜ë¦¬
test_RID <- change_rid(test$RID)
# dim(test)
test_path <- file.path(atlas_export_path, "test")
dir.create(test_path, showWarnings = FALSE)
cat(crayon::cyan("[INFO] Processing Test Data for Atlas:"), crayon::bold(file_name), "\n")
test_params <- c(list(path_FC_atlas = path_atlas,
target_RID = test_RID,
path_export = test_path),
final_options)
do.call(smoothing_multiple_ROIs, test_params)
# ğŸŸ¢ ê° í´ë“œì— ëŒ€í•´ Train ë° Validation ë°ì´í„° ì²˜ë¦¬
for (fold in seq(1, 5)) {
train_data <- train_folded[[paste0("Fold_", fold, "_Train")]]
validation_data <- train_folded[[paste0("Fold_", fold, "_Validation")]]
train_RID <- change_rid(train_data$RID)
validation_RID <- change_rid(validation_data$RID)
# Train ë°ì´í„° ì²˜ë¦¬
train_path <- file.path(atlas_export_path, "train", paste0("fold_", fold))
dir.create(train_path, recursive = TRUE, showWarnings = FALSE)
cat(crayon::cyan("[INFO] Processing Train Data for Fold:"), fold, "-", crayon::bold(file_name), "\n")
train_params <- c(list(path_FC_atlas = path_atlas,
target_RID = train_RID,
path_export = train_path),
final_options)
do.call(smoothing_multiple_ROIs, train_params)
# Validation ë°ì´í„° ì²˜ë¦¬
validation_path <- file.path(atlas_export_path, "validation", paste0("fold_", fold))
dir.create(validation_path, recursive = TRUE, showWarnings = FALSE)
cat(crayon::cyan("[INFO] Processing Validation Data for Fold:"), fold, "-", crayon::bold(file_name), "\n")
validation_params <- c(list(path_FC_atlas = path_atlas,
target_RID = validation_RID,
path_export = validation_path),
final_options)
do.call(smoothing_multiple_ROIs, validation_params)
}
}
}
## ğŸŸ¨ Multiple : smoothing by bspline gcv =======================================================================
smoothing_multiple_ROIs <- function(path_FC_atlas,
target_RID,  # ìˆ˜ì •: train_RID -> target_RID
n_order,
n_breaks = NULL,
lambdas,
path_export,
save_each_ROI = FALSE,
width = 2000,
overwrite = TRUE) {
### ğŸŸ© ê²½ë¡œ ì„¤ì • =====================================================
atlas_name <- tools::file_path_sans_ext(basename(path_FC_atlas))
export_path <- file.path(path_export)
# ë‚´ë³´ë‚´ê¸° ë””ë ‰í„°ë¦¬ ìƒì„±
if (!dir.exists(export_path)) {
tryCatch({
dir.create(export_path, recursive = TRUE)
cat(crayon::green("Created export directory at:"), crayon::bold(export_path), "\n")
}, error = function(e) {
stop(crayon::red("Error: Failed to create export directory at:"), crayon::bold(export_path), "\n")
})
}
# ê²°ê³¼ íŒŒì¼ ê²½ë¡œ ì„¤ì •
results_file <- file.path(export_path, paste0("results_smoothed_", atlas_name, ".rds"))
### ğŸŸ© ë°ì´í„° ì²˜ë¦¬ =====================================================
if (file.exists(results_file)) {
cat(crayon::blue("[INFO] Skipping processing for atlas:"), crayon::bgMagenta(atlas_name), "\n")
} else {
# Atlas íŒŒì¼ ë¡œë“œ
FC <- readRDS(path_FC_atlas)
# ëŒ€ìƒ RIDì— í•´ë‹¹í•˜ëŠ” ì—´ ì„ íƒ
FC_filtered <- lapply(FC, function(X) {
X %>% select(all_of(c(names(X)[1:2], target_RID)))
}) %>% setNames(names(FC))
# ê° ROIì— ëŒ€í•´ smoothing ìˆ˜í–‰
results <- lapply(names(FC_filtered), function(roi_name) {
process_single_ROI(
roi_name, FC_filtered, export_path, n_order, lambdas,
n_breaks, width, overwrite, save_each_ROI
)
}) %>% setNames(names(FC_filtered))
# ê²°ê³¼ ì €ì¥
results <- results[!sapply(results, is.null)]
if (length(results) > 0) {
saveRDS(results, results_file)
cat(crayon::green("[INFO] Saved results at:"), crayon::bold(results_file), "\n")
} else {
cat(crayon::yellow("[INFO] No new results to save.\n"))
}
}
}
## ğŸŸ¨ Single ROI =======================================================================
process_single_ROI <- function(roi_name, FC, atlas_export_path, n_order, lambdas,
n_breaks, width, overwrite, save_each_ROI) {
require(crayon)
cat(crayon::cyan("[INFO] Processing ROI:"), bold(roi_name), "\n")
# kth_ROI = FC_train[[roi_name]]
kth_ROI <- FC[[roi_name]]
domain <- kth_ROI %>% select(ends_with("Dist")) %>% unlist %>% as.numeric
names(domain) = kth_ROI$ROI
kth_ROI = kth_ROI %>% select(-ROI, -ends_with("Dist"))
file_name <- paste0(roi_name, "_smoothed_result.png")
file_path <- file.path(atlas_export_path, file_name)
# ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš° ì²˜ë¦¬ ê±´ë„ˆë›°ê¸°
if (file.exists(file_path) && file.info(file_path)$size > 0 && !overwrite) {
cat(crayon::yellow("[INFO] Skipping ROI:"), bold(roi_name), "\n")
return(NULL)
}
if (save_each_ROI) {
rds_file_path <- file.path(atlas_export_path, paste0(roi_name, "_smoothed.rds"))
if (file.exists(rds_file_path) && file.info(rds_file_path)$size > 0) {
cat(crayon::yellow("[INFO] ROI already processed:"), crayon::bold(roi_name), "\n")
return(readRDS(rds_file_path))
}
}
# ìŠ¤ë¬´ë”© ìˆ˜í–‰
smoothing_result <- smoothing_by_bspline_gcv(
kth_ROI, domain, n_order, lambdas, n_breaks,
path_export = atlas_export_path,
file_name = roi_name,
width = width, overwrite = overwrite
)
if (save_each_ROI) {
rds_file_path <- file.path(atlas_export_path, paste0(roi_name, "_smoothed.rds"))
tryCatch({
saveRDS(smoothing_result, rds_file_path)
cat(crayon::green("[INFO] Saved result for ROI:"), bold(roi_name), "\n")
}, error = function(e) {
cat(crayon::red("[ERROR] Failed to save result for ROI:"), bold(roi_name), "\n")
})
}
return(smoothing_result)
}
## ğŸŸ¨ Single : smoothing by bspline gcv =======================================================================
smoothing_by_bspline_gcv <- function(kth_ROI,
domain,
n_order,
lambdas,
n_breaks = NULL,
path_export = NULL,
file_name = "smoothing_result",
width = 2000,
overwrite = TRUE) {
library(magrittr)
library(fda)
library(crayon)
# Convert to numeric
convert_all_to_numeric <- function(df) {
df[] <- lapply(df, function(col) {
as.numeric(as.character(col))
})
return(df)
}
# Convert kth_ROI to matrix
X <- kth_ROI %>% convert_all_to_numeric %>% as.matrix()
if (is.null(n_breaks)) {
n_breaks <- nrow(X)
}
# Lambda í‘œì‹œë¥¼ ìœ„í•œ exp í˜•íƒœ ìƒì„±
opt_lambda <- lambdas[which.min(sapply(lambdas, function(ith_lambda) {
tryCatch({
fdPar_obj <- fdPar(fdobj = create.bspline.basis(
rangeval = c(min(domain), max(domain)),
norder = n_order,
breaks = seq(from = min(domain), to = max(domain), length.out = n_breaks)),
Lfdobj = int2Lfd(2), lambda = ith_lambda)
mean(smooth.basis(argvals = domain, y = X, fdParobj = fdPar_obj)$gcv)
}, error = function(e) {
NA
})
}))]
opt_lambda_exp <- paste0("exp(", round(log(opt_lambda), 2), ")")
# After íŒŒì¼ ì´ë¦„ì— ì˜µì…˜ í¬í•¨
file_name_after <- paste0(
file_name, "_n_order=", n_order,
"_lambda=", opt_lambda_exp,
"_n_breaks=", n_breaks, "_after"
)
# Helper function to add rotated x-axis labels
add_rotated_x_labels <- function(domain) {
labels <- if (!is.null(names(domain))) names(domain) else as.character(domain)
axis(1, at = domain, labels = FALSE)  # ê¸°ë³¸ xì¶• ëˆˆê¸ˆ ì¶”ê°€
text(x = domain, y = par("usr")[3] - 0.05 * diff(par("usr")[3:4]),
labels = labels, srt = 45, adj = 1, xpd = TRUE)  # ë ˆì´ë¸” íšŒì „ ì¶”ê°€
}
# Before smoothing plot
if (!is.null(path_export)) {
file_path_before <- file.path(path_export, paste0(file_name, "_before.png"))
if (file.exists(file_path_before) && !overwrite) {
cat(yellow("Skipping initial plot: File already exists at"), bold(file_path_before), "\n")
} else {
png(filename = file_path_before, width = width, height = 600)
matplot(x = domain, y = X, type = "l", col = 1:ncol(X), lty = 1,
main = "Original Data Before Smoothing", xaxt = "n")
add_rotated_x_labels(domain)  # íšŒì „ëœ xì¶• ë ˆì´ë¸” ì¶”ê°€
dev.off()
cat(green("Saved plot before smoothing at:"), bold(file_path_before), "\n")
}
}
# Smoothing using the optimal parameter
opt_fdPar_obj <- fdPar(
fdobj = create.bspline.basis(rangeval = c(min(domain), max(domain)),
norder = n_order,
breaks = seq(from = min(domain), to = max(domain), length.out = n_breaks)),
Lfdobj = int2Lfd(2), lambda = opt_lambda
)
opt_fdSmooth_obj <- smooth.basis(argvals = domain, y = X, fdParobj = opt_fdPar_obj)
# After smoothing plot
if (!is.null(path_export)) {
file_path_after <- file.path(path_export, paste0(file_name_after, ".png"))
if (file.exists(file_path_after) && !overwrite) {
cat(yellow("Skipping plot after smoothing: File already exists at"), bold(file_path_after), "\n")
} else {
png(filename = file_path_after, width = width, height = 600)
plot(opt_fdSmooth_obj$fd, col = 1:ncol(X), lty = 1,
main = paste("Optimal Smoothing with lambda =", opt_lambda), xaxt = "n")
add_rotated_x_labels(domain)  # íšŒì „ëœ xì¶• ë ˆì´ë¸” ì¶”ê°€
dev.off()
cat(green("Saved plot after smoothing at:"), bold(file_path_after), "\n")
}
}
return(list(fdSmooth_obj = opt_fdSmooth_obj, lambda = opt_lambda))
}
## ğŸŸ¨ FunImgARCWSF ====================================================================================================================
path_FC = "/Volumes/ADNI_SB_SSD_NTFS_4TB_Sandisk/FunCurv/2.Construction of curves by distance/3.Curves by Distance/FunImgARCWSF/Fisher Z FC"
path_FC = path_FC %>% adjust_path
path_FC
path_export = "/Volumes/ADNI_SB_SSD_NTFS_4TB_Sandisk/FunCurv/2.Construction of curves by distance/4.Smoothing curves by B-spline basis expansion/FunImgARCWSF_FC"
path_export = path_export %>% adjust_path
path_export
apply_smoothing_to_atlas_files(base_path = path_FC,
train_folded,
test,
options_for_each_atlas_list = options_for_each_atlas_list,
common_options = list(path_export = path_export,
save_each_ROI = FALSE,
overwrite = FALSE))
## ğŸŸ¨ ê° atlasì— ëŒ€í•œ ì˜µì…˜ ì •ì˜ ==============================================================================
options_for_each_atlas_list <- list(
AAL3 = list(n_order = 4,
n_breaks = 300,
lambdas = exp(seq(-1, 0, 0.5))),
"1000Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-4, -3, 0.5))),
"900Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-3, -2, 0.5))),
"800Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-3, -2, 0.5))),
"700Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-3, -2, 0.5))),
"600Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-2, -1, 0.5))),
"500Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-2, -1, 0.5))),
"400Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-2, -1, 0.5))),
"300Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-2, -1, 0.5))),
"200Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-2, -1, 0.5))),
"100Parcels" = list(n_order = 4,
n_breaks = NULL,
lambdas = exp(seq(-2, -1, 0.5)))
)
## ğŸŸ¨ FunImgARglobalCWSF ====================================================================================================================
path_FC = "/Volumes/ADNI_SB_SSD_NTFS_4TB_Sandisk/FunCurv/2.Construction of curves by distance/3.Curves by Distance/FunImgARglobalCWSF/zReHo"
path_FC = path_FC %>% adjust_path
path_export = "/Volumes/ADNI_SB_SSD_NTFS_4TB_Sandisk/FunCurv/2.Construction of curves by distance/4.Smoothing curves by B-spline basis expansion/FunImgARglobalCWSF_zReHo"
path_export = path_export %>% adjust_path
apply_smoothing_to_atlas_files(base_path = path_FC,
train_folded,
test,
options_for_each_atlas_list = options_for_each_atlas_list,
common_options = list(path_export = path_export,
save_each_ROI = FALSE,
overwrite = TRUE))
